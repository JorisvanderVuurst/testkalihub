#!/usr/bin/env python3
# PenTest Hub - A comprehensive interface for penetration testing tools
# Author: cerlux

import os
import sys
import subprocess
import argparse
import json
import platform
import socket
import requests
import threading
import time
import re
from datetime import datetime
from colorama import init, Fore, Style, Back

# Initialize colorama for cross-platform colored terminal output
init()

class PenTestHub:
    def __init__(self):
        self.version = "3.5"
        self.config_dir = os.path.expanduser("~/.pentesthub")
        self.history_file = os.path.join(self.config_dir, "history.json")
        self.config_file = os.path.join(self.config_dir, "config.json")
        self.custom_tools_file = os.path.join(self.config_dir, "custom_tools.json")
        
        # Ensure config directory exists
        if not os.path.exists(self.config_dir):
            os.makedirs(self.config_dir)
        
        # Load custom tools if file exists
        self.custom_tools = {}
        if os.path.exists(self.custom_tools_file):
            try:
                with open(self.custom_tools_file, 'r') as f:
                    self.custom_tools = json.load(f)
            except:
                print(f"{Fore.RED}Error loading custom tools file.{Style.RESET_ALL}")
        
        self.tools = {
            # Reconnaissance
            "nmap": {"desc": "Network scanner", "cmd": "nmap", "category": "recon"},
            "whois": {"desc": "Domain information lookup", "cmd": "whois", "category": "recon"},
            "dig": {"desc": "DNS lookup utility", "cmd": "dig", "category": "recon"},
            "theHarvester": {"desc": "Email and subdomain harvesting", "cmd": "theHarvester", "category": "recon"},
            "recon-ng": {"desc": "Web reconnaissance framework", "cmd": "recon-ng", "category": "recon"},
            "amass": {"desc": "In-depth Attack Surface Mapping", "cmd": "amass", "category": "recon"},
            "subfinder": {"desc": "Subdomain discovery tool", "cmd": "subfinder", "category": "recon"},
            "gobuster": {"desc": "Directory/file & DNS busting tool", "cmd": "gobuster", "category": "recon"},
            "masscan": {"desc": "Fast port scanner", "cmd": "masscan", "category": "recon"},
            "dnsenum": {"desc": "DNS enumeration tool", "cmd": "dnsenum", "category": "recon"},
            "fierce": {"desc": "DNS analysis tool", "cmd": "fierce", "category": "recon"},
            "sublist3r": {"desc": "Fast subdomains enumeration", "cmd": "sublist3r", "category": "recon"},
            "photon": {"desc": "OSINT web crawler", "cmd": "photon", "category": "recon"},
            "reconftw": {"desc": "Reconnaissance framework", "cmd": "reconftw", "category": "recon"},
            
            # Web Application
            "nikto": {"desc": "Web server scanner", "cmd": "nikto", "category": "web"},
            "dirb": {"desc": "Web content scanner", "cmd": "dirb", "category": "web"},
            "sqlmap": {"desc": "SQL injection automation", "cmd": "sqlmap", "category": "web"},
            "wpscan": {"desc": "WordPress vulnerability scanner", "cmd": "wpscan", "category": "web"},
            "burpsuite": {"desc": "Web application proxy", "cmd": "burpsuite", "category": "web"},
            "owasp-zap": {"desc": "Web app vulnerability scanner", "cmd": "owasp-zap-2.12.0.sh", "category": "web"},
            "ffuf": {"desc": "Fast web fuzzer", "cmd": "ffuf", "category": "web"},
            "wafw00f": {"desc": "Web Application Firewall detector", "cmd": "wafw00f", "category": "web"},
            "whatweb": {"desc": "Web scanner", "cmd": "whatweb", "category": "web"},
            "nuclei": {"desc": "Vulnerability scanner", "cmd": "nuclei", "category": "web"},
            "xsser": {"desc": "XSS vulnerability scanner", "cmd": "xsser", "category": "web"},
            "commix": {"desc": "Command injection scanner", "cmd": "commix", "category": "web"},
            "feroxbuster": {"desc": "Fast content discovery tool", "cmd": "feroxbuster", "category": "web"},
            "httpx": {"desc": "HTTP toolkit", "cmd": "httpx", "category": "web"},
            "gau": {"desc": "Get All URLs", "cmd": "gau", "category": "web"},
            "hakrawler": {"desc": "Web crawler for gathering URLs", "cmd": "hakrawler", "category": "web"},
            
            # Wireless
            "aircrack-ng": {"desc": "Wireless network security suite", "cmd": "aircrack-ng", "category": "wireless"},
            "wifite": {"desc": "Automated wireless attack tool", "cmd": "wifite", "category": "wireless"},
            "kismet": {"desc": "Wireless network detector", "cmd": "kismet", "category": "wireless"},
            "bettercap": {"desc": "Network attack & monitoring", "cmd": "bettercap", "category": "wireless"},
            "airgeddon": {"desc": "Multi-use bash script for Linux systems", "cmd": "airgeddon", "category": "wireless"},
            "wifiphisher": {"desc": "Rogue Access Point framework", "cmd": "wifiphisher", "category": "wireless"},
            "fluxion": {"desc": "MITM WPA attack framework", "cmd": "fluxion", "category": "wireless"},
            "eaphammer": {"desc": "Targeted evil twin attacks", "cmd": "eaphammer", "category": "wireless"},
            "wifi-pumpkin": {"desc": "Framework for rogue access point attack", "cmd": "wifi-pumpkin", "category": "wireless"},
            
            # Password Attacks
            "hydra": {"desc": "Login cracker", "cmd": "hydra", "category": "password"},
            "john": {"desc": "Password cracker", "cmd": "john", "category": "password"},
            "hashcat": {"desc": "Advanced password recovery", "cmd": "hashcat", "category": "password"},
            "medusa": {"desc": "Parallel login brute-forcer", "cmd": "medusa", "category": "password"},
            "crunch": {"desc": "Wordlist generator", "cmd": "crunch", "category": "password"},
            "cewl": {"desc": "Custom word list generator", "cmd": "cewl", "category": "password"},
            "rsmangler": {"desc": "Wordlist manipulation tool", "cmd": "rsmangler", "category": "password"},
            "hashid": {"desc": "Hash identifier", "cmd": "hashid", "category": "password"},
            "patator": {"desc": "Multi-purpose brute-forcer", "cmd": "patator", "category": "password"},
            "thc-pptp-bruter": {"desc": "PPTP VPN brute forcer", "cmd": "thc-pptp-bruter", "category": "password"},
            "crowbar": {"desc": "Brute forcing tool (RDP, SSH, VNC)", "cmd": "crowbar", "category": "password"},
            "mentalist": {"desc": "Graphical wordlist generator", "cmd": "mentalist", "category": "password"},
            
            # Exploitation
            "metasploit": {"desc": "Exploitation framework", "cmd": "msfconsole", "category": "exploit"},
            "searchsploit": {"desc": "Exploit database search", "cmd": "searchsploit", "category": "exploit"},
            "beef-xss": {"desc": "Browser exploitation framework", "cmd": "beef-xss", "category": "exploit"},
            "set": {"desc": "Social-Engineer Toolkit", "cmd": "setoolkit", "category": "exploit"},
            "routersploit": {"desc": "Router exploitation framework", "cmd": "rsf", "category": "exploit"},
            "commix": {"desc": "Command injection exploiter", "cmd": "commix", "category": "exploit"},
            "armitage": {"desc": "Metasploit GUI", "cmd": "armitage", "category": "exploit"},
            "veil": {"desc": "Payload generator", "cmd": "veil", "category": "exploit"},
            "koadic": {"desc": "COM Command & Control", "cmd": "koadic", "category": "exploit"},
            "empire": {"desc": "PowerShell post-exploitation", "cmd": "empire", "category": "exploit"},
            "unicorn": {"desc": "PowerShell downgrade attack tool", "cmd": "unicorn.py", "category": "exploit"},
            "shellnoob": {"desc": "Shellcode writing toolkit", "cmd": "shellnoob", "category": "exploit"},
            
            # Sniffing & Spoofing
            "wireshark": {"desc": "Network protocol analyzer", "cmd": "wireshark", "category": "sniffing"},
            "ettercap": {"desc": "MITM attacks", "cmd": "ettercap -G", "category": "sniffing"},
            "responder": {"desc": "LLMNR/NBT-NS/mDNS poisoner", "cmd": "responder", "category": "sniffing"},
            "tcpdump": {"desc": "Network packet analyzer", "cmd": "tcpdump", "category": "sniffing"},
            "dsniff": {"desc": "Network sniffing tools", "cmd": "dsniff", "category": "sniffing"},
            "mitmproxy": {"desc": "Interactive HTTPS proxy", "cmd": "mitmproxy", "category": "sniffing"},
            "scapy": {"desc": "Packet manipulation", "cmd": "scapy", "category": "sniffing"},
            "netsniff-ng": {"desc": "High performance network sniffer", "cmd": "netsniff-ng", "category": "sniffing"},
            "arpspoof": {"desc": "ARP spoofing", "cmd": "arpspoof", "category": "sniffing"},
            "bettercap": {"desc": "Swiss army knife for network attacks", "cmd": "bettercap", "category": "sniffing"},
            "yersinia": {"desc": "Layer 2 attack framework", "cmd": "yersinia", "category": "sniffing"},
            
            # Post Exploitation
            "empire": {"desc": "Post-exploitation framework", "cmd": "empire", "category": "post"},
            "mimikatz": {"desc": "Windows credential dumper", "cmd": "mimikatz", "category": "post"},
            "powersploit": {"desc": "PowerShell post-exploitation", "cmd": "powersploit", "category": "post"},
            "bloodhound": {"desc": "Active Directory visualizer", "cmd": "bloodhound", "category": "post"},
            "evil-winrm": {"desc": "Windows Remote Management shell", "cmd": "evil-winrm", "category": "post"},
            "impacket": {"desc": "Network protocols toolkit", "cmd": "impacket-scripts", "category": "post"},
            "crackmapexec": {"desc": "Swiss army knife for networks", "cmd": "crackmapexec", "category": "post"},
            "weevely": {"desc": "Weaponized web shell", "cmd": "weevely", "category": "post"},
            "pupy": {"desc": "Remote administration tool", "cmd": "pupy", "category": "post"},
            "powercat": {"desc": "PowerShell netcat", "cmd": "powercat", "category": "post"},
            "chisel": {"desc": "Fast TCP/UDP tunnel", "cmd": "chisel", "category": "post"},
            "ligolo-ng": {"desc": "Advanced tunneling tool", "cmd": "ligolo-ng", "category": "post"},
            
            # Forensics
            "volatility": {"desc": "Memory forensics", "cmd": "volatility", "category": "forensics"},
            "autopsy": {"desc": "Digital forensics platform", "cmd": "autopsy", "category": "forensics"},
            "foremost": {"desc": "File recovery", "cmd": "foremost", "category": "forensics"},
            "binwalk": {"desc": "Firmware analysis", "cmd": "binwalk", "category": "forensics"},
            "exiftool": {"desc": "Metadata analyzer", "cmd": "exiftool", "category": "forensics"},
            "scalpel": {"desc": "File carver", "cmd": "scalpel", "category": "forensics"},
            "bulk_extractor": {"desc": "Feature extractor", "cmd": "bulk_extractor", "category": "forensics"},
            "chkrootkit": {"desc": "Rootkit detector", "cmd": "chkrootkit", "category": "forensics"},
            "rkhunter": {"desc": "Rootkit hunter", "cmd": "rkhunter", "category": "forensics"},
            "sleuthkit": {"desc": "Forensic toolkit", "cmd": "sleuthkit", "category": "forensics"},
            "ddrescue": {"desc": "Data recovery tool", "cmd": "ddrescue", "category": "forensics"},
            "testdisk": {"desc": "Partition recovery", "cmd": "testdisk", "category": "forensics"},
            
            # Reporting
            "maltego": {"desc": "Interactive data mining", "cmd": "maltego", "category": "reporting"},
            "faraday": {"desc": "Collaborative pentesting environment", "cmd": "faraday-client", "category": "reporting"},
            "dradis": {"desc": "Reporting and collaboration", "cmd": "dradis", "category": "reporting"},
            "magictree": {"desc": "Data management for tests", "cmd": "magictree", "category": "reporting"},
            "cherrytree": {"desc": "Hierarchical note taking", "cmd": "cherrytree", "category": "reporting"},
            "pipal": {"desc": "Password analyzer", "cmd": "pipal", "category": "reporting"},
            
            # Mobile
            "apktool": {"desc": "Android APK analysis", "cmd": "apktool", "category": "mobile"},
            "dex2jar": {"desc": "Android dex to jar converter", "cmd": "d2j-dex2jar", "category": "mobile"},
            "jadx": {"desc": "Dex to Java decompiler", "cmd": "jadx", "category": "mobile"},
            "frida": {"desc": "Dynamic instrumentation toolkit", "cmd": "frida", "category": "mobile"},
            "objection": {"desc": "Mobile exploration toolkit", "cmd": "objection", "category": "mobile"},
            "mobsf": {"desc": "Mobile Security Framework", "cmd": "mobsf", "category": "mobile"},
            "drozer": {"desc": "Android security assessment", "cmd": "drozer", "category": "mobile"},
            "adb": {"desc": "Android Debug Bridge", "cmd": "adb", "category": "mobile"},
            
            # OSINT
            "maltego": {"desc": "OSINT visualization", "cmd": "maltego", "category": "osint"},
            "shodan": {"desc": "Search engine for Internet-connected devices", "cmd": "shodan", "category": "osint"},
            "osrframework": {"desc": "Username checking tools", "cmd": "osrframework", "category": "osint"},
            "spiderfoot": {"desc": "OSINT automation tool", "cmd": "spiderfoot", "category": "osint"},
            "recon-ng": {"desc": "Web reconnaissance framework", "cmd": "recon-ng", "category": "osint"},
            "metagoofil": {"desc": "Metadata extraction tool", "cmd": "metagoofil", "category": "osint"},
            "osintgram": {"desc": "Instagram OSINT tool", "cmd": "osintgram", "category": "osint"},
            "sherlock": {"desc": "Hunt down social media accounts", "cmd": "sherlock", "category": "osint"},
            "h8mail": {"desc": "Email OSINT and breach hunting", "cmd": "h8mail", "category": "osint"},
            "twint": {"desc": "Twitter Intelligence Tool", "cmd": "twint", "category": "osint"},
            
            # Utilities
            "ncat": {"desc": "Networking utility", "cmd": "ncat", "category": "utility"},
            "socat": {"desc": "Multipurpose relay", "cmd": "socat", "category": "utility"},
            "tmux": {"desc": "Terminal multiplexer", "cmd": "tmux", "category": "utility"},
            "screen": {"desc": "Terminal multiplexer", "cmd": "screen", "category": "utility"},
            "proxychains": {"desc": "Proxy redirection", "cmd": "proxychains", "category": "utility"},
            "tor": {"desc": "Anonymity network", "cmd": "tor", "category": "utility"},
            "macchanger": {"desc": "MAC address spoofer", "cmd": "macchanger", "category": "utility"},
            "sshuttle": {"desc": "VPN over SSH", "cmd": "sshuttle", "category": "utility"},
            "termshark": {"desc": "Terminal UI for tshark", "cmd": "termshark", "category": "utility"},
            "httpie": {"desc": "Command-line HTTP client", "cmd": "http", "category": "utility"},
            
            # Reverse Engineering
            "ghidra": {"desc": "Software reverse engineering", "cmd": "ghidra", "category": "reverse"},
            "radare2": {"desc": "Reverse engineering framework", "cmd": "r2", "category": "reverse"},
            "gdb": {"desc": "GNU Debugger", "cmd": "gdb", "category": "reverse"},
            "ida-free": {"desc": "Interactive disassembler", "cmd": "ida-free", "category": "reverse"},
            "peda": {"desc": "Python Exploit Development Assistance for GDB", "cmd": "peda", "category": "reverse"},
            "pwndbg": {"desc": "GDB plug-in for exploit development", "cmd": "pwndbg", "category": "reverse"},
            
            # Cloud Security
            "awscli": {"desc": "AWS Command Line Interface", "cmd": "aws", "category": "cloud"},
            "s3scanner": {"desc": "Scan for open S3 buckets", "cmd": "s3scanner", "category": "cloud"},
            "pacu": {"desc": "AWS exploitation framework", "cmd": "pacu", "category": "cloud"},
            "cloudsploit": {"desc": "Cloud security scanning", "cmd": "cloudsploit", "category": "cloud"},
            "azurecli": {"desc": "Azure Command Line Interface", "cmd": "az", "category": "cloud"},
            "gcloud": {"desc": "Google Cloud CLI", "cmd": "gcloud", "category": "cloud"},
        }
        
        # Merge custom tools
        self.tools.update(self.custom_tools)
        
        # Build categories from tools
        self.categories = {}
        for tool_name, tool_info in self.tools.items():
            category = tool_info.get("category", "uncategorized")
            if category not in self.categories:
                self.categories[category] = []
            self.categories[category].append(tool_name)
        
        self.common_commands = {
            "nmap": {
                "basic": "nmap [target]",
                "full": "nmap -sC -sV -p- [target]",
                "stealth": "nmap -sS -T2 [target]",
                "udp": "nmap -sU [target]",
                "vuln_scan": "nmap --script vuln [target]",
                "os_detection": "nmap -O [target]",
                "aggressive": "nmap -A [target]"
            },
            "sqlmap": {
                "basic": "sqlmap -u [url]",
                "with_data": "sqlmap -u [url] --data=\"[post_data]\"",
                "cookie": "sqlmap -u [url] --cookie=\"[cookie]\"",
                "dump": "sqlmap -u [url] --dbms=[dbms] --dump",
                "os_shell": "sqlmap -u [url] --os-shell",
                "risk_level": "sqlmap -u [url] --risk=3 --level=5"
            },
            "hydra": {
                "ssh": "hydra -l [username] -P [wordlist] ssh://[target]",
                "web_form": "hydra -l [username] -P [wordlist] [target] http-post-form \"[path]:[params]:F=[fail_msg]\"",
                "ftp": "hydra -l [username] -P [wordlist] ftp://[target]",
                "smb": "hydra -l [username] -P [wordlist] smb://[target]",
                "rdp": "hydra -l [username] -P [wordlist] rdp://[target]"
            },
            "metasploit": {
                "search": "search [keyword]",
                "use": "use [module]",
                "set": "set [option] [value]",
                "run": "run",
                "exploit": "exploit",
                "sessions": "sessions -l",
                "background": "background"
            },
            "aircrack-ng": {
                "monitor_mode": "airmon-ng start [interface]",
                "capture": "airodump-ng [monitor_interface]",
                "targeted_capture": "airodump-ng -c [channel] --bssid [bssid] -w [output_file] [monitor_interface]",
                "deauth": "aireplay-ng --deauth [count] -a [bssid] [monitor_interface]",
                "crack_wpa": "aircrack-ng -w [wordlist] [capture_file.cap]"
            },
            "hashcat": {
                "md5": "hashcat -m 0 -a 0 [hash_file] [wordlist]",
                "sha1": "hashcat -m 100 -a 0 [hash_file] [wordlist]",
                "ntlm": "hashcat -m 1000 -a 0 [hash_file] [wordlist]",
                "wpa": "hashcat -m 22000 -a 0 [hash_file] [wordlist]",
                "rule_based": "hashcat -m 0 -a 0 [hash_file] [wordlist] -r [rule_file]"
            },
            "john": {
                "basic": "john [hash_file]",
                "wordlist": "john --wordlist=[wordlist] [hash_file]",
                "format": "john --format=[format] [hash_file]",
                "incremental": "john --incremental [hash_file]",
                "show": "john --show [hash_file]"
            },
            "gobuster": {
                "dir": "gobuster dir -u [url] -w [wordlist]",
                "dns": "gobuster dns -d [domain] -w [wordlist]",
                "vhost": "gobuster vhost -u [url] -w [wordlist]",
                "dir_advanced": "gobuster dir -u [url] -w [wordlist] -x [extensions] -t [threads]"
            },
            "ffuf": {
                "dir": "ffuf -u [url]/FUZZ -w [wordlist]",
                "vhost": "ffuf -u http://FUZZ.[domain] -w [wordlist]",
                "parameter": "ffuf -u [url]?FUZZ=value -w [wordlist]",
                "post_data": "ffuf -u [url] -X POST -d 'FUZZ=value' -w [wordlist]"
            },
            "crackmapexec": {
                "smb": "crackmapexec smb [target] -u [username] -p [password]",
                "winrm": "crackmapexec winrm [target] -u [username] -p [password]",
                "mssql": "crackmapexec mssql [target] -u [username] -p [password]",
                "smb_shares": "crackmapexec smb [target] -u [username] -p [password] --shares"
            }
        }
        
        # Command history
        self.history = []
        if os.path.exists(self.history_file):
            try:
                with open(self.history_file, 'r') as f:
                    self.history = json.load(f)
            except:
                pass
        
        # Favorites list
        self.favorites_file = os.path.join(self.config_dir, "favorites.json")
        self.favorites = []
        if os.path.exists(self.favorites_file):
            try:
                with open(self.favorites_file, 'r') as f:
                    self.favorites = json.load(f)
            except:
                pass
        
        # Quick access presets
        self.presets_file = os.path.join(self.config_dir, "presets.json")
        self.presets = {
            "quick_recon": "nmap -sV -sC [target]",
            "full_scan": "nmap -p- -T4 [target]",
            "web_scan": "nikto -h [target]",
            "dir_scan": "gobuster dir -u [target] -w /usr/share/wordlists/dirb/common.txt",
            "wifi_scan": "airodump-ng [interface]",
            "quick_vuln": "nuclei -u [target]",
            "subdomain_enum": "subfinder -d [domain] | httpx",
            "wordpress_scan": "wpscan --url [target] --enumerate u",
            "smb_enum": "crackmapexec smb [target] --shares",
            "stealth_scan": "nmap -sS -T2 [target]"
        }
        if os.path.exists(self.presets_file):
            try:
                with open(self.presets_file, 'r') as f:
                    self.presets.update(json.load(f))
            except:
                pass
                
        # Show menu on startup if running in Kali Linux
        if platform.system() == "Linux" and os.path.exists("/etc/os-release"):
            try:
                with open("/etc/os-release", "r") as f:
                    if "kali" in f.read().lower():
                        self.show_menu()
            except:
                pass
    
    def save_history(self):
        """Save command history to file"""
        try:
            with open(self.history_file, 'w') as f:
                json.dump(self.history[-100:], f)  # Keep last 100 commands
        except Exception as e:
            print(f"{Fore.RED}Error saving history: {str(e)}{Style.RESET_ALL}")
    
    def save_custom_tools(self):
        """Save custom tools to file"""
        try:
            with open(self.custom_tools_file, 'w') as f:
                json.dump(self.custom_tools, f, indent=2)
        except Exception as e:
            print(f"{Fore.RED}Error saving custom tools: {str(e)}{Style.RESET_ALL}")
    
    def save_favorites(self):
        """Save favorites to file"""
        try:
            with open(self.favorites_file, 'w') as f:
                json.dump(self.favorites, f, indent=2)
        except Exception as e:
            print(f"{Fore.RED}Error saving favorites: {str(e)}{Style.RESET_ALL}")
    
    def save_presets(self):
        """Save presets to file"""
        try:
            with open(self.presets_file, 'w') as f:
                json.dump(self.presets, f, indent=2)
        except Exception as e:
            print(f"{Fore.RED}Error saving presets: {str(e)}{Style.RESET_ALL}")
    
    def add_custom_tool(self, name, description, command, category):
        """Add a custom tool to the collection"""
        self.custom_tools[name] = {
            "desc": description,
            "cmd": command,
            "category": category
        }
        
        # Update main tools dictionary
        self.tools[name] = self.custom_tools[name]
        
        # Update categories
        if category not in self.categories:
            self.categories[category] = []
        if name not in self.categories[category]:
            self.categories[category].append(name)
        
        self.save_custom_tools()
        print(f"\n{Fore.GREEN}Tool '{name}' added successfully.{Style.RESET_ALL}\n")
    
    def remove_custom_tool(self, name):
        """Remove a custom tool"""
        if name in self.custom_tools:
            category = self.custom_tools[name].get("category", "uncategorized")
            
            # Remove from custom tools
            del self.custom_tools[name]
            
            # Remove from main tools dictionary
            if name in self.tools:
                del self.tools[name]
            
            # Remove from categories
            if category in self.categories and name in self.categories[category]:
                self.categories[category].remove(name)
            
            self.save_custom_tools()
            print(f"\n{Fore.GREEN}Tool '{name}' removed successfully.{Style.RESET_ALL}\n")
        else:
            print(f"\n{Fore.RED}'{name}' is not a custom tool.{Style.RESET_ALL}\n")
    
    def show_menu(self):
        """Display interactive menu with all options"""
        os.system('clear' if platform.system() != 'Windows' else 'cls')
        self.print_banner()
        
        print(f"\n{Fore.CYAN}╔══════════════════════════════════════════╗")
        print(f"║ {Fore.GREEN}PenTest Hub - Main Menu{Fore.CYAN}                 ║")
        print(f"╚══════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}[1] {Fore.WHITE}Browse Tools by Category")
        print(f"{Fore.YELLOW}[2] {Fore.WHITE}Search for Tools")
        print(f"{Fore.YELLOW}[3] {Fore.WHITE}Quick Access Presets")
        print(f"{Fore.YELLOW}[4] {Fore.WHITE}Favorites")
        print(f"{Fore.YELLOW}[5] {Fore.WHITE}Command History")
        print(f"{Fore.YELLOW}[6] {Fore.WHITE}Add Custom Tool")
        print(f"{Fore.YELLOW}[7] {Fore.WHITE}Remove Custom Tool")
        print(f"{Fore.YELLOW}[8] {Fore.WHITE}System Information")
        print(f"{Fore.YELLOW}[9] {Fore.WHITE}Network Tools")
        print(f"{Fore.YELLOW}[0] {Fore.WHITE}Exit")
        
        choice = input(f"\n{Fore.GREEN}Enter your choice (0-9): {Style.RESET_ALL}")
        
        if choice == '1':
            self.browse_categories()
        elif choice == '2':
            search_term = input(f"\n{Fore.GREEN}Enter search term: {Style.RESET_ALL}")
            self.search_tools(search_term)
        elif choice == '3':
            self.manage_presets()
        elif choice == '4':
            self.manage_favorites()
        elif choice == '5':
            self.show_history()
        elif choice == '6':
            self.add_custom_tool_interactive()
        elif choice == '7':
            self.remove_custom_tool_interactive()
        elif choice == '8':
            self.show_system_info()
        elif choice == '9':
            self.show_network_tools()
        elif choice == '0':
            print(f"\n{Fore.GREEN}Exiting PenTest Hub. Goodbye!{Style.RESET_ALL}")
            sys.exit(0)
        else:
            print(f"\n{Fore.RED}Invalid choice. Press Enter to continue...{Style.RESET_ALL}")
            input()
            self.show_menu()
    
    def print_banner(self):
        banner = f"""
{Fore.CYAN}╔══════════════════════════════════════════════════════════════════════════╗
║ {Fore.GREEN}██████╗ ███████╗███╗   ██╗████████╗███████╗███████╗████████╗{Fore.CYAN}          ║
║ {Fore.GREEN}██╔══██╗██╔════╝████╗  ██║╚══██╔══╝██╔════╝██╔════╝╚══██╔══╝{Fore.CYAN}          ║
║ {Fore.GREEN}██████╔╝█████╗  ██╔██╗ ██║   ██║   █████╗  ███████╗   ██║   {Fore.CYAN}          ║
║ {Fore.GREEN}██╔═══╝ ██╔══╝  ██║╚██╗██║   ██║   ██╔══╝  ╚════██║   ██║   {Fore.CYAN}          ║
║ {Fore.GREEN}██║     ███████╗██║ ╚████║   ██║   ███████╗███████║   ██║   {Fore.CYAN}          ║
║ {Fore.GREEN}╚═╝     ╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝╚══════╝   ╚═╝   {Fore.CYAN}          ║
║                                                                      ║
║ {Fore.RED}██╗  ██╗██╗   ██╗██████╗ {Fore.CYAN}                                         ║
║ {Fore.RED}██║  ██║██║   ██║██╔══██╗{Fore.CYAN}                                         ║
║ {Fore.RED}███████║██║   ██║██████╔╝{Fore.CYAN}                                         ║
║ {Fore.RED}██╔══██║██║   ██║██╔══██╗{Fore.CYAN}                                         ║
║ {Fore.RED}██║  ██║╚██████╔╝██████╔╝{Fore.CYAN}                                         ║
║ {Fore.RED}╚═╝  ╚═╝ ╚═════╝ ╚═════╝ {Fore.CYAN}                                         ║
╚══════════════════════════════════════════════════════════════════════════╝
{Style.RESET_ALL}
{Fore.GREEN}[*] PenTest Hub v{self.version} - Your Ultimate Penetration Testing Command Center
{Fore.YELLOW}[+] Type 'help' or '?' to see available commands | 'menu' for interactive menu{Style.RESET_ALL}
{Fore.RED}[!] Warning: Use responsibly and only on systems you have permission to test{Style.RESET_ALL}
"""
        print(banner)
    
    def browse_categories(self):
        """Browse tools by category"""
        os.system('clear' if platform.system() != 'Windows' else 'cls')
        self.print_banner()
        
        print(f"\n{Fore.CYAN}╔══════════════════════════════════════════╗")
        print(f"║ {Fore.GREEN}Browse Tools by Category{Fore.CYAN}                ║")
        print(f"╚══════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        # Display categories
        categories = sorted(self.categories.keys())
        for i, category in enumerate(categories, 1):
            print(f"{Fore.YELLOW}[{i}] {Fore.WHITE}{category.capitalize()} ({len(self.categories[category])} tools)")
        
        print(f"\n{Fore.YELLOW}[0] {Fore.WHITE}Back to Main Menu")
        
        choice = input(f"\n{Fore.GREEN}Enter category number (0-{len(categories)}): {Style.RESET_ALL}")
        
        if choice == '0':
            self.show_menu()
            return
        
        try:
            category_index = int(choice) - 1
            if 0 <= category_index < len(categories):
                self.show_category_tools(categories[category_index])
            else:
                print(f"\n{Fore.RED}Invalid choice. Press Enter to continue...{Style.RESET_ALL}")
                input()
                self.browse_categories()
        except ValueError:
            print(f"\n{Fore.RED}Invalid input. Press Enter to continue...{Style.RESET_ALL}")
            input()
            self.browse_categories()
    
    def show_category_tools(self, category):
        """Show tools in a specific category"""
        os.system('clear' if platform.system() != 'Windows' else 'cls')
        self.print_banner()
        
        print(f"\n{Fore.CYAN}╔══════════════════════════════════════════╗")
        print(f"║ {Fore.GREEN}Category: {category.capitalize()}{' ' * (27 - len(category))}{Fore.CYAN}║")
        print(f"╚══════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        tools = sorted(self.categories[category])
        for i, tool in enumerate(tools, 1):
            desc = self.tools[tool]["desc"]
            print(f"{Fore.YELLOW}[{i}] {Fore.WHITE}{tool} - {desc}")
        
        print(f"\n{Fore.YELLOW}[0] {Fore.WHITE}Back to Categories")
        
        choice = input(f"\n{Fore.GREEN}Enter tool number or 0 to go back: {Style.RESET_ALL}")
        
        if choice == '0':
            self.browse_categories()
            return
        
        try:
            tool_index = int(choice) - 1
            if 0 <= tool_index < len(tools):
                self.run_tool(tools[tool_index])
            else:
                print(f"\n{Fore.RED}Invalid choice. Press Enter to continue...{Style.RESET_ALL}")
                input()
                self.show_category_tools(category)
        except ValueError:
            print(f"\n{Fore.RED}Invalid input. Press Enter to continue...{Style.RESET_ALL}")
            input()
            self.show_category_tools(category)
    
    def run_tool(self, tool_name):
        """Run a selected tool"""
        if tool_name not in self.tools:
            print(f"\n{Fore.RED}Tool '{tool_name}' not found.{Style.RESET_ALL}")
            input("\nPress Enter to continue...")
            return
        
        tool = self.tools[tool_name]
        cmd = tool["cmd"]
        
        # Check if tool has common commands
        if tool_name in self.common_commands:
            self.show_common_commands(tool_name)
        else:
            # Run the basic command
            print(f"\n{Fore.GREEN}Running {tool_name}...{Style.RESET_ALL}")
            try:
                subprocess.run(cmd, shell=True)
                self.add_to_history(tool_name, cmd)
            except Exception as e:
                print(f"\n{Fore.RED}Error running {tool_name}: {str(e)}{Style.RESET_ALL}")
            
            input("\nPress Enter to continue...")
    
    def show_common_commands(self, tool_name):
        """Show common commands for a tool"""
        os.system('clear' if platform.system() != 'Windows' else 'cls')
        self.print_banner()
        
        print(f"\n{Fore.CYAN}╔══════════════════════════════════════════╗")
        print(f"║ {Fore.GREEN}Common Commands: {tool_name}{' ' * (19 - len(tool_name))}{Fore.CYAN}║")
        print(f"╚══════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        commands = self.common_commands[tool_name]
        options = list(commands.keys())
        
        for i, option in enumerate(options, 1):
            print(f"{Fore.YELLOW}[{i}] {Fore.WHITE}{option}: {commands[option]}")
        
        print(f"\n{Fore.YELLOW}[c] {Fore.WHITE}Custom Command")
        print(f"{Fore.YELLOW}[0] {Fore.WHITE}Back")
        
        choice = input(f"\n{Fore.GREEN}Enter option: {Style.RESET_ALL}")
        
        if choice == '0':
            return
        elif choice.lower() == 'c':
            custom_cmd = input(f"\n{Fore.GREEN}Enter custom command (tool name will be prepended): {Style.RESET_ALL}")
            full_cmd = f"{self.tools[tool_name]['cmd']} {custom_cmd}"
            print(f"\n{Fore.GREEN}Running: {full_cmd}{Style.RESET_ALL}")
            try:
                subprocess.run(full_cmd, shell=True)
                self.add_to_history(tool_name, full_cmd)
            except Exception as e:
                print(f"\n{Fore.RED}Error: {str(e)}{Style.RESET_ALL}")
        else:
            try:
                option_index = int(choice) - 1
                if 0 <= option_index < len(options):
                    option = options[option_index]
                    cmd_template = commands[option]
                    
                    # Replace placeholders with user input
                    if '[' in cmd_template and ']' in cmd_template:
                        placeholders = re.findall(r'\[(.*?)\]', cmd_template)
                        cmd = cmd_template
                        for placeholder in placeholders:
                            value = input(f"\n{Fore.GREEN}Enter {placeholder}: {Style.RESET_ALL}")
                            cmd = cmd.replace(f"[{placeholder}]", value)
                    else:
                        cmd = cmd_template
                    
                    print(f"\n{Fore.GREEN}Running: {cmd}{Style.RESET_ALL}")
                    try:
                        subprocess.run(cmd, shell=True)
                        self.add_to_history(tool_name, cmd)
                    except Exception as e:
                        print(f"\n{Fore.RED}Error: {str(e)}{Style.RESET_ALL}")
                else:
                    print(f"\n{Fore.RED}Invalid choice.{Style.RESET_ALL}")
            except ValueError:
                print(f"\n{Fore.RED}Invalid input.{Style.RESET_ALL}")
        
        input("\nPress Enter to continue...")
    
    def search_tools(self, term):
        """Search for tools by name or description"""
        os.system('clear' if platform.system() != 'Windows' else 'cls')
        self.print_banner()
        
        print(f"\n{Fore.CYAN}╔══════════════════════════════════════════╗")
        print(f"║ {Fore.GREEN}Search Results: '{term}'{' ' * (19 - len(term))}{Fore.CYAN}║")
        print(f"╚══════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        results = []
        term = term.lower()
        
        for tool_name, tool_info in self.tools.items():
            if term in tool_name.lower() or term in tool_info["desc"].lower():
                results.append(tool_name)
        
        if not results:
            print(f"{Fore.RED}No tools found matching '{term}'.{Style.RESET_ALL}")
        else:
            for i, tool in enumerate(sorted(results), 1):
                desc = self.tools[tool]["desc"]
                category = self.tools[tool]["category"]
                print(f"{Fore.YELLOW}[{i}] {Fore.WHITE}{tool} - {desc} {Fore.CYAN}[{category}]{Style.RESET_ALL}")
            
            print(f"\n{Fore.YELLOW}[0] {Fore.WHITE}Back to Main Menu")
            
            choice = input(f"\n{Fore.GREEN}Enter tool number or 0 to go back: {Style.RESET_ALL}")
            
            if choice == '0':
                self.show_menu()
                return
            
            try:
                tool_index = int(choice) - 1
                if 0 <= tool_index < len(results):
                    self.run_tool(sorted(results)[tool_index])
                else:
                    print(f"\n{Fore.RED}Invalid choice. Press Enter to continue...{Style.RESET_ALL}")
            except ValueError:
                print(f"\n{Fore.RED}Invalid input. Press Enter to continue...{Style.RESET_ALL}")
        
        input("\nPress Enter to continue...")
        self.show_menu()
    
    def add_custom_tool_interactive(self):
        """Interactive interface to add a custom tool"""
        os.system('clear' if platform.system() != 'Windows' else 'cls')
        self.print_banner()
        
        print(f"\n{Fore.CYAN}╔══════════════════════════════════════════╗")
        print(f"║ {Fore.GREEN}Add Custom Tool{Fore.CYAN}                        ║")
        print(f"╚══════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        name = input(f"{Fore.GREEN}Enter tool name: {Style.RESET_ALL}")
        if not name:
            print(f"\n{Fore.RED}Tool name cannot be empty.{Style.RESET_ALL}")
            input("\nPress Enter to continue...")
            self.show_menu()
            return
        
        if name in self.tools and name not in self.custom_tools:
            print(f"\n{Fore.RED}A built-in tool with this name already exists.{Style.RESET_ALL}")
            input("\nPress Enter to continue...")
            self.show_menu()
            return
        
        description = input(f"{Fore.GREEN}Enter tool description: {Style.RESET_ALL}")
        command = input(f"{Fore.GREEN}Enter command to run the tool: {Style.RESET_ALL}")
        
        # Show existing categories
        print(f"\n{Fore.CYAN}Existing categories:{Style.RESET_ALL}")
        categories = sorted(self.categories.keys())
        for i, category in enumerate(categories, 1):
            print(f"{Fore.YELLOW}[{i}] {Fore.WHITE}{category}")
        
        print(f"{Fore.YELLOW}[n] {Fore.WHITE}Create new category")
        
        category_choice = input(f"\n{Fore.GREEN}Select category number or 'n' for new: {Style.RESET_ALL}")
        
        if category_choice.lower() == 'n':
            category = input(f"{Fore.GREEN}Enter new category name: {Style.RESET_ALL}")
        else:
            try:
                category_index = int(category_choice) - 1
                if 0 <= category_index < len(categories):
                    category = categories[category_index]
                else:
                    print(f"\n{Fore.RED}Invalid choice. Using 'uncategorized'.{Style.RESET_ALL}")
                    category = "uncategorized"
            except ValueError:
                print(f"\n{Fore.RED}Invalid input. Using 'uncategorized'.{Style.RESET_ALL}")
                category = "uncategorized"
        
        self.add_custom_tool(name, description, command, category)
        input("\nPress Enter to continue...")
        self.show_menu()
    
    def remove_custom_tool_interactive(self):
        """Interactive interface to remove a custom tool"""
        os.system('clear' if platform.system() != 'Windows' else 'cls')
        self.print_banner()
        
        print(f"\n{Fore.CYAN}╔══════════════════════════════════════════╗")
        print(f"║ {Fore.GREEN}Remove Custom Tool{Fore.CYAN}                     ║")
        print(f"╚══════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        if not self.custom_tools:
            print(f"{Fore.RED}No custom tools found.{Style.RESET_ALL}")
            input("\nPress Enter to continue...")
            self.show_menu()
            return
        
        custom_tools = sorted(self.custom_tools.keys())
        for i, tool in enumerate(custom_tools, 1):
            desc = self.custom_tools[tool]["desc"]
            print(f"{Fore.YELLOW}[{i}] {Fore.WHITE}{tool} - {desc}")
        
        print(f"\n{Fore.YELLOW}[0] {Fore.WHITE}Back to Main Menu")
        
        choice = input(f"\n{Fore.GREEN}Enter tool number to remove or 0 to go back: {Style.RESET_ALL}")
        
        if choice == '0':
            self.show_menu()
            return
        
        try:
            tool_index = int(choice) - 1
            if 0 <= tool_index < len(custom_tools):
                tool_name = custom_tools[tool_index]
                confirm = input(f"\n{Fore.RED}Are you sure you want to remove '{tool_name}'? (y/n): {Style.RESET_ALL}")
                if confirm.lower() == 'y':
                    self.remove_custom_tool(tool_name)
            else:
                print(f"\n{Fore.RED}Invalid choice.{Style.RESET_ALL}")
        except ValueError:
            print(f"\n{Fore.RED}Invalid input.{Style.RESET_ALL}")
        
        input("\nPress Enter to continue...")
        self.show_menu()
    
    def manage_presets(self):
        """Manage quick access presets"""
        os.system('clear' if platform.system() != 'Windows' else 'cls')
        self.print_banner()
        
        print(f"\n{Fore.CYAN}╔══════════════════════════════════════════╗")
        print(f"║ {Fore.GREEN}Quick Access Presets{Fore.CYAN}                   ║")
        print(f"╚══════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}[1] {Fore.WHITE}View Presets")
        print(f"{Fore.YELLOW}[2] {Fore.WHITE}Add Preset")
        print(f"{Fore.YELLOW}[3] {Fore.WHITE}Remove Preset")
        print(f"{Fore.YELLOW}[0] {Fore.WHITE}Back to Main Menu")
        
        choice = input(f"\n{Fore.GREEN}Enter your choice: {Style.RESET_ALL}")
        
        if choice == '1':
            self.view_presets()
        elif choice == '2':
            self.add_preset_interactive()
        elif choice == '3':
            self.remove_preset_interactive()
        elif choice == '0':
            self.show_menu()
        else:
            print(f"\n{Fore.RED}Invalid choice.{Style.RESET_ALL}")
            input("\nPress Enter to continue...")
            self.manage_presets()
    
    def show_system_info(self):
        """Display system information"""
        os.system('clear' if platform.system() != 'Windows' else 'cls')
        self.print_banner()
        
        print(f"\n{Fore.CYAN}╔══════════════════════════════════════════╗")
        print(f"║ {Fore.GREEN}System Information{Fore.CYAN}                     ║")
        print(f"╚══════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}Operating System:{Style.RESET_ALL} {platform.system()} {platform.release()}")
        print(f"{Fore.YELLOW}Architecture:{Style.RESET_ALL} {platform.machine()}")
        print(f"{Fore.YELLOW}Hostname:{Style.RESET_ALL} {socket.gethostname()}")
        
        try:
            ip_address = socket.gethostbyname(socket.gethostname())
            print(f"{Fore.YELLOW}IP Address:{Style.RESET_ALL} {ip_address}")
        except:
            print(f"{Fore.YELLOW}IP Address:{Style.RESET_ALL} Unable to determine")
        
        print(f"\n{Fore.YELLOW}Python Version:{Style.RESET_ALL} {platform.python_version()}")
        print(f"{Fore.YELLOW}PenTest Hub Version:{Style.RESET_ALL} {self.version}")
        
        input("\nPress Enter to continue...")
        self.show_menu()
    
    def show_network_tools(self):
        """Show network tools menu"""
        os.system('clear' if platform.system() != 'Windows' else 'cls')
        self.print_banner()
        
        print(f"\n{Fore.CYAN}╔══════════════════════════════════════════╗")
        print(f"║ {Fore.GREEN}Network Tools{Fore.CYAN}                          ║")
        print(f"╚══════════════════════════════════════════╝{Style.RESET_ALL}\n")
        
        print(f"{Fore.YELLOW}[1] {Fore.WHITE}IP Information")
        print(f"{Fore.YELLOW}[2] {Fore.WHITE}DNS Lookup")
        print(f"{Fore.YELLOW}[3] {Fore.WHITE}Port Scanner")
        print(f"{Fore.YELLOW}[4] {Fore.WHITE}Ping Host")
        print(f"{Fore.YELLOW}[5] {Fore.WHITE}Traceroute")
        print(f"{Fore.YELLOW}[0] {Fore.WHITE}Back to Main Menu")
        
        choice = input(f"\n{Fore.GREEN}Enter your choice: {Style.RESET_ALL}")
        
        if choice == '1':
            self.show_ip_info()
        elif choice == '2':
            self.dns_lookup()
        elif choice == '3':
            self.port_scanner()
        elif choice == '4':
            self.ping_host()
        elif choice == '5':
            self.traceroute()
        elif choice == '0':
            self.show_menu()
        else:
            print(f"\n{Fore.RED}Invalid choice.{Style.RESET_ALL}")
            input("\nPress Enter to continue...")
            self.show_network_tools()
