#!/usr/bin/env python3
# PenTest Hub - A comprehensive interface for penetration testing tools
# Author: cerlux

import os
import sys
import subprocess
import argparse
import json
import platform
import socket
import requests
import threading
import time
import re
from datetime import datetime
from colorama import init, Fore, Style, Back

# Initialize colorama for cross-platform colored terminal output
init()

class PenTestHub:
    def __init__(self):
        self.version = "3.5"
        self.config_dir = os.path.expanduser("~/.pentesthub")
        self.history_file = os.path.join(self.config_dir, "history.json")
        self.config_file = os.path.join(self.config_dir, "config.json")
        self.custom_tools_file = os.path.join(self.config_dir, "custom_tools.json")
        
        # Ensure config directory exists
        if not os.path.exists(self.config_dir):
            os.makedirs(self.config_dir)
        
        # Load custom tools if file exists
        self.custom_tools = {}
        if os.path.exists(self.custom_tools_file):
            try:
                with open(self.custom_tools_file, 'r') as f:
                    self.custom_tools = json.load(f)
            except:
                print(f"{Fore.RED}Error loading custom tools file.{Style.RESET_ALL}")
        
        self.tools = {
            # Reconnaissance
            "nmap": {"desc": "Network scanner", "cmd": "nmap", "category": "recon"},
            "whois": {"desc": "Domain information lookup", "cmd": "whois", "category": "recon"},
            "dig": {"desc": "DNS lookup utility", "cmd": "dig", "category": "recon"},
            "theHarvester": {"desc": "Email and subdomain harvesting", "cmd": "theHarvester", "category": "recon"},
            "recon-ng": {"desc": "Web reconnaissance framework", "cmd": "recon-ng", "category": "recon"},
            "amass": {"desc": "In-depth Attack Surface Mapping", "cmd": "amass", "category": "recon"},
            "subfinder": {"desc": "Subdomain discovery tool", "cmd": "subfinder", "category": "recon"},
            "gobuster": {"desc": "Directory/file & DNS busting tool", "cmd": "gobuster", "category": "recon"},
            "masscan": {"desc": "Fast port scanner", "cmd": "masscan", "category": "recon"},
            "dnsenum": {"desc": "DNS enumeration tool", "cmd": "dnsenum", "category": "recon"},
            "fierce": {"desc": "DNS analysis tool", "cmd": "fierce", "category": "recon"},
            "sublist3r": {"desc": "Fast subdomains enumeration", "cmd": "sublist3r", "category": "recon"},
            
            # Web Application
            "nikto": {"desc": "Web server scanner", "cmd": "nikto", "category": "web"},
            "dirb": {"desc": "Web content scanner", "cmd": "dirb", "category": "web"},
            "sqlmap": {"desc": "SQL injection automation", "cmd": "sqlmap", "category": "web"},
            "wpscan": {"desc": "WordPress vulnerability scanner", "cmd": "wpscan", "category": "web"},
            "burpsuite": {"desc": "Web application proxy", "cmd": "burpsuite", "category": "web"},
            "owasp-zap": {"desc": "Web app vulnerability scanner", "cmd": "owasp-zap-2.12.0.sh", "category": "web"},
            "ffuf": {"desc": "Fast web fuzzer", "cmd": "ffuf", "category": "web"},
            "wafw00f": {"desc": "Web Application Firewall detector", "cmd": "wafw00f", "category": "web"},
            "whatweb": {"desc": "Web scanner", "cmd": "whatweb", "category": "web"},
            "nuclei": {"desc": "Vulnerability scanner", "cmd": "nuclei", "category": "web"},
            "xsser": {"desc": "XSS vulnerability scanner", "cmd": "xsser", "category": "web"},
            "commix": {"desc": "Command injection scanner", "cmd": "commix", "category": "web"},
            
            # Wireless
            "aircrack-ng": {"desc": "Wireless network security suite", "cmd": "aircrack-ng", "category": "wireless"},
            "wifite": {"desc": "Automated wireless attack tool", "cmd": "wifite", "category": "wireless"},
            "kismet": {"desc": "Wireless network detector", "cmd": "kismet", "category": "wireless"},
            "bettercap": {"desc": "Network attack & monitoring", "cmd": "bettercap", "category": "wireless"},
            "airgeddon": {"desc": "Multi-use bash script for Linux systems", "cmd": "airgeddon", "category": "wireless"},
            "wifiphisher": {"desc": "Rogue Access Point framework", "cmd": "wifiphisher", "category": "wireless"},
            "fluxion": {"desc": "MITM WPA attack framework", "cmd": "fluxion", "category": "wireless"},
            
            # Password Attacks
            "hydra": {"desc": "Login cracker", "cmd": "hydra", "category": "password"},
            "john": {"desc": "Password cracker", "cmd": "john", "category": "password"},
            "hashcat": {"desc": "Advanced password recovery", "cmd": "hashcat", "category": "password"},
            "medusa": {"desc": "Parallel login brute-forcer", "cmd": "medusa", "category": "password"},
            "crunch": {"desc": "Wordlist generator", "cmd": "crunch", "category": "password"},
            "cewl": {"desc": "Custom word list generator", "cmd": "cewl", "category": "password"},
            "rsmangler": {"desc": "Wordlist manipulation tool", "cmd": "rsmangler", "category": "password"},
            "hashid": {"desc": "Hash identifier", "cmd": "hashid", "category": "password"},
            "patator": {"desc": "Multi-purpose brute-forcer", "cmd": "patator", "category": "password"},
            
            # Exploitation
            "metasploit": {"desc": "Exploitation framework", "cmd": "msfconsole", "category": "exploit"},
            "searchsploit": {"desc": "Exploit database search", "cmd": "searchsploit", "category": "exploit"},
            "beef-xss": {"desc": "Browser exploitation framework", "cmd": "beef-xss", "category": "exploit"},
            "set": {"desc": "Social-Engineer Toolkit", "cmd": "setoolkit", "category": "exploit"},
            "routersploit": {"desc": "Router exploitation framework", "cmd": "rsf", "category": "exploit"},
            "commix": {"desc": "Command injection exploiter", "cmd": "commix", "category": "exploit"},
            "armitage": {"desc": "Metasploit GUI", "cmd": "armitage", "category": "exploit"},
            "veil": {"desc": "Payload generator", "cmd": "veil", "category": "exploit"},
            
            # Sniffing & Spoofing
            "wireshark": {"desc": "Network protocol analyzer", "cmd": "wireshark", "category": "sniffing"},
            "ettercap": {"desc": "MITM attacks", "cmd": "ettercap -G", "category": "sniffing"},
            "responder": {"desc": "LLMNR/NBT-NS/mDNS poisoner", "cmd": "responder", "category": "sniffing"},
            "tcpdump": {"desc": "Network packet analyzer", "cmd": "tcpdump", "category": "sniffing"},
            "dsniff": {"desc": "Network sniffing tools", "cmd": "dsniff", "category": "sniffing"},
            "mitmproxy": {"desc": "Interactive HTTPS proxy", "cmd": "mitmproxy", "category": "sniffing"},
            "scapy": {"desc": "Packet manipulation", "cmd": "scapy", "category": "sniffing"},
            "netsniff-ng": {"desc": "High performance network sniffer", "cmd": "netsniff-ng", "category": "sniffing"},
            "arpspoof": {"desc": "ARP spoofing", "cmd": "arpspoof", "category": "sniffing"},
            
            # Post Exploitation
            "empire": {"desc": "Post-exploitation framework", "cmd": "empire", "category": "post"},
            "mimikatz": {"desc": "Windows credential dumper", "cmd": "mimikatz", "category": "post"},
            "powersploit": {"desc": "PowerShell post-exploitation", "cmd": "powersploit", "category": "post"},
            "bloodhound": {"desc": "Active Directory visualizer", "cmd": "bloodhound", "category": "post"},
            "evil-winrm": {"desc": "Windows Remote Management shell", "cmd": "evil-winrm", "category": "post"},
            "impacket": {"desc": "Network protocols toolkit", "cmd": "impacket-scripts", "category": "post"},
            "crackmapexec": {"desc": "Swiss army knife for networks", "cmd": "crackmapexec", "category": "post"},
            "weevely": {"desc": "Weaponized web shell", "cmd": "weevely", "category": "post"},
            
            # Forensics
            "volatility": {"desc": "Memory forensics", "cmd": "volatility", "category": "forensics"},
            "autopsy": {"desc": "Digital forensics platform", "cmd": "autopsy", "category": "forensics"},
            "foremost": {"desc": "File recovery", "cmd": "foremost", "category": "forensics"},
            "binwalk": {"desc": "Firmware analysis", "cmd": "binwalk", "category": "forensics"},
            "exiftool": {"desc": "Metadata analyzer", "cmd": "exiftool", "category": "forensics"},
            "scalpel": {"desc": "File carver", "cmd": "scalpel", "category": "forensics"},
            "bulk_extractor": {"desc": "Feature extractor", "cmd": "bulk_extractor", "category": "forensics"},
            "chkrootkit": {"desc": "Rootkit detector", "cmd": "chkrootkit", "category": "forensics"},
            "rkhunter": {"desc": "Rootkit hunter", "cmd": "rkhunter", "category": "forensics"},
            
            # Reporting
            "maltego": {"desc": "Interactive data mining", "cmd": "maltego", "category": "reporting"},
            "faraday": {"desc": "Collaborative pentesting environment", "cmd": "faraday-client", "category": "reporting"},
            "dradis": {"desc": "Reporting and collaboration", "cmd": "dradis", "category": "reporting"},
            "magictree": {"desc": "Data management for tests", "cmd": "magictree", "category": "reporting"},
            
            # Mobile
            "apktool": {"desc": "Android APK analysis", "cmd": "apktool", "category": "mobile"},
            "dex2jar": {"desc": "Android dex to jar converter", "cmd": "d2j-dex2jar", "category": "mobile"},
            "jadx": {"desc": "Dex to Java decompiler", "cmd": "jadx", "category": "mobile"},
            "frida": {"desc": "Dynamic instrumentation toolkit", "cmd": "frida", "category": "mobile"},
            "objection": {"desc": "Mobile exploration toolkit", "cmd": "objection", "category": "mobile"},
            
            # OSINT
            "maltego": {"desc": "OSINT visualization", "cmd": "maltego", "category": "osint"},
            "shodan": {"desc": "Search engine for Internet-connected devices", "cmd": "shodan", "category": "osint"},
            "osrframework": {"desc": "Username checking tools", "cmd": "osrframework", "category": "osint"},
            "spiderfoot": {"desc": "OSINT automation tool", "cmd": "spiderfoot", "category": "osint"},
            "recon-ng": {"desc": "Web reconnaissance framework", "cmd": "recon-ng", "category": "osint"},
            "metagoofil": {"desc": "Metadata extraction tool", "cmd": "metagoofil", "category": "osint"},
            
            # Utilities
            "ncat": {"desc": "Networking utility", "cmd": "ncat", "category": "utility"},
            "socat": {"desc": "Multipurpose relay", "cmd": "socat", "category": "utility"},
            "tmux": {"desc": "Terminal multiplexer", "cmd": "tmux", "category": "utility"},
            "screen": {"desc": "Terminal multiplexer", "cmd": "screen", "category": "utility"},
            "proxychains": {"desc": "Proxy redirection", "cmd": "proxychains", "category": "utility"},
            "tor": {"desc": "Anonymity network", "cmd": "tor", "category": "utility"},
            "macchanger": {"desc": "MAC address spoofer", "cmd": "macchanger", "category": "utility"},
        }
        
        # Merge custom tools
        self.tools.update(self.custom_tools)
        
        # Build categories from tools
        self.categories = {}
        for tool_name, tool_info in self.tools.items():
            category = tool_info.get("category", "uncategorized")
            if category not in self.categories:
                self.categories[category] = []
            self.categories[category].append(tool_name)
        
        self.common_commands = {
            "nmap": {
                "basic": "nmap [target]",
                "full": "nmap -sC -sV -p- [target]",
                "stealth": "nmap -sS -T2 [target]",
                "udp": "nmap -sU [target]",
                "vuln_scan": "nmap --script vuln [target]",
                "os_detection": "nmap -O [target]",
                "aggressive": "nmap -A [target]"
            },
            "sqlmap": {
                "basic": "sqlmap -u [url]",
                "with_data": "sqlmap -u [url] --data=\"[post_data]\"",
                "cookie": "sqlmap -u [url] --cookie=\"[cookie]\"",
                "dump": "sqlmap -u [url] --dbms=[dbms] --dump",
                "os_shell": "sqlmap -u [url] --os-shell",
                "risk_level": "sqlmap -u [url] --risk=3 --level=5"
            },
            "hydra": {
                "ssh": "hydra -l [username] -P [wordlist] ssh://[target]",
                "web_form": "hydra -l [username] -P [wordlist] [target] http-post-form \"[path]:[params]:F=[fail_msg]\"",
                "ftp": "hydra -l [username] -P [wordlist] ftp://[target]",
                "smb": "hydra -l [username] -P [wordlist] smb://[target]",
                "rdp": "hydra -l [username] -P [wordlist] rdp://[target]"
            },
            "metasploit": {
                "search": "search [keyword]",
                "use": "use [module]",
                "set": "set [option] [value]",
                "run": "run",
                "exploit": "exploit",
                "sessions": "sessions -l",
                "background": "background"
            },
            "aircrack-ng": {
                "monitor_mode": "airmon-ng start [interface]",
                "capture": "airodump-ng [monitor_interface]",
                "targeted_capture": "airodump-ng -c [channel] --bssid [bssid] -w [output_file] [monitor_interface]",
                "deauth": "aireplay-ng --deauth [count] -a [bssid] [monitor_interface]",
                "crack_wpa": "aircrack-ng -w [wordlist] [capture_file.cap]"
            },
            "hashcat": {
                "md5": "hashcat -m 0 -a 0 [hash_file] [wordlist]",
                "sha1": "hashcat -m 100 -a 0 [hash_file] [wordlist]",
                "ntlm": "hashcat -m 1000 -a 0 [hash_file] [wordlist]",
                "wpa": "hashcat -m 22000 -a 0 [hash_file] [wordlist]",
                "rule_based": "hashcat -m 0 -a 0 [hash_file] [wordlist] -r [rule_file]"
            },
            "john": {
                "basic": "john [hash_file]",
                "wordlist": "john --wordlist=[wordlist] [hash_file]",
                "format": "john --format=[format] [hash_file]",
                "incremental": "john --incremental [hash_file]",
                "show": "john --show [hash_file]"
            },
            "gobuster": {
                "dir": "gobuster dir -u [url] -w [wordlist]",
                "dns": "gobuster dns -d [domain] -w [wordlist]",
                "vhost": "gobuster vhost -u [url] -w [wordlist]",
                "dir_advanced": "gobuster dir -u [url] -w [wordlist] -x [extensions] -t [threads]"
            },
            "ffuf": {
                "dir": "ffuf -u [url]/FUZZ -w [wordlist]",
                "vhost": "ffuf -u http://FUZZ.[domain] -w [wordlist]",
                "parameter": "ffuf -u [url]?FUZZ=value -w [wordlist]",
                "post_data": "ffuf -u [url] -X POST -d 'FUZZ=value' -w [wordlist]"
            },
            "crackmapexec": {
                "smb": "crackmapexec smb [target] -u [username] -p [password]",
                "winrm": "crackmapexec winrm [target] -u [username] -p [password]",
                "mssql": "crackmapexec mssql [target] -u [username] -p [password]",
                "smb_shares": "crackmapexec smb [target] -u [username] -p [password] --shares"
            }
        }
        
        # Command history
        self.history = []
        if os.path.exists(self.history_file):
            try:
                with open(self.history_file, 'r') as f:
                    self.history = json.load(f)
            except:
                pass
        
        # Favorites list
        self.favorites_file = os.path.join(self.config_dir, "favorites.json")
        self.favorites = []
        if os.path.exists(self.favorites_file):
            try:
                with open(self.favorites_file, 'r') as f:
                    self.favorites = json.load(f)
            except:
                pass
        
        # Quick access presets
        self.presets_file = os.path.join(self.config_dir, "presets.json")
        self.presets = {
            "quick_recon": "nmap -sV -sC [target]",
            "full_scan": "nmap -p- -T4 [target]",
            "web_scan": "nikto -h [target]",
            "dir_scan": "gobuster dir -u [target] -w /usr/share/wordlists/dirb/common.txt",
            "wifi_scan": "airodump-ng [interface]"
        }
        if os.path.exists(self.presets_file):
            try:
                with open(self.presets_file, 'r') as f:
                    self.presets.update(json.load(f))
            except:
                pass
    
    def save_history(self):
        """Save command history to file"""
        try:
            with open(self.history_file, 'w') as f:
                json.dump(self.history[-100:], f)  # Keep last 100 commands
        except Exception as e:
            print(f"{Fore.RED}Error saving history: {str(e)}{Style.RESET_ALL}")
    
    def save_custom_tools(self):
        """Save custom tools to file"""
        try:
            with open(self.custom_tools_file, 'w') as f:
                json.dump(self.custom_tools, f, indent=2)
        except Exception as e:
            print(f"{Fore.RED}Error saving custom tools: {str(e)}{Style.RESET_ALL}")
    
    def save_favorites(self):
        """Save favorites to file"""
        try:
            with open(self.favorites_file, 'w') as f:
                json.dump(self.favorites, f, indent=2)
        except Exception as e:
            print(f"{Fore.RED}Error saving favorites: {str(e)}{Style.RESET_ALL}")
    
    def save_presets(self):
        """Save presets to file"""
        try:
            with open(self.presets_file, 'w') as f:
                json.dump(self.presets, f, indent=2)
        except Exception as e:
            print(f"{Fore.RED}Error saving presets: {str(e)}{Style.RESET_ALL}")
    
    def add_custom_tool(self, name, description, command, category):
        """Add a custom tool to the collection"""
        self.custom_tools[name] = {
            "desc": description,
            "cmd": command,
            "category": category
        }
        
        # Update main tools dictionary
        self.tools[name] = self.custom_tools[name]
        
        # Update categories
        if category not in self.categories:
            self.categories[category] = []
        if name not in self.categories[category]:
            self.categories[category].append(name)
        
        self.save_custom_tools()
        print(f"\n{Fore.GREEN}Tool '{name}' added successfully.{Style.RESET_ALL}\n")
    
    def remove_custom_tool(self, name):
        """Remove a custom tool"""
        if name in self.custom_tools:
            category = self.custom_tools[name].get("category", "uncategorized")
            
            # Remove from custom tools
            del self.custom_tools[name]
            
            # Remove from main tools dictionary
            if name in self.tools:
                del self.tools[name]
            
            # Remove from categories
            if category in self.categories and name in self.categories[category]:
                self.categories[category].remove(name)
            
            self.save_custom_tools()
            print(f"\n{Fore.GREEN}Tool '{name}' removed successfully.{Style.RESET_ALL}\n")
        else:
            print(f"\n{Fore.RED}'{name}' is not a custom tool.{Style.RESET_ALL}\n")
    
    def print_banner(self):
        banner = f"""
{Fore.CYAN}╔══════════════════════════════════════════════════════════════════════════╗
║ {Fore.GREEN}██████╗ ███████╗███╗   ██╗████████╗███████╗███████╗████████╗{Fore.CYAN}          ║
║ {Fore.GREEN}██╔══██╗██╔════╝████╗  ██║╚══██╔══╝██╔════╝██╔════╝╚══██╔══╝{Fore.CYAN}          ║
║ {Fore.GREEN}██████╔╝█████╗  ██╔██╗ ██║   ██║   █████╗  ███████╗   ██║   {Fore.CYAN}          ║
║ {Fore.GREEN}██╔═══╝ ██╔══╝  ██║╚██╗██║   ██║   ██╔══╝  ╚════██║   ██║   {Fore.CYAN}          ║
║ {Fore.GREEN}██║     ███████╗██║ ╚████║   ██║   ███████╗███████║   ██║   {Fore.CYAN}          ║
║ {Fore.GREEN}╚═╝     ╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝╚══════╝   ╚═╝   {Fore.CYAN}          ║
║                                                                      ║
║ {Fore.RED}██╗  ██╗██╗   ██╗██████╗ {Fore.CYAN}                                         ║
║ {Fore.RED}██║  ██║██║   ██║██╔══██╗{Fore.CYAN}                                         ║
║ {Fore.RED}███████║██║   ██║██████╔╝{Fore.CYAN}                                         ║
║ {Fore.RED}██╔══██║██║   ██║██╔══██╗{Fore.CYAN}                                         ║
║ {Fore.RED}██║  ██║╚██████╔╝██████╔╝{Fore.CYAN}                                         ║
║ {Fore.RED}╚═╝  ╚═╝ ╚═════╝ ╚═════╝ {Fore.CYAN}                                         ║
╚══════════════════════════════════════════════════════════════════════════╝
{Style.RESET_ALL}
{Fore.GREEN}[*] PenTest Hub v{self.version} - Your Ultimate Penetration Testing Command Center
{Fore.YELLOW}[+] Type 'help' or '?' to see available commands | 'menu' for interactive menu{Style.RESET_ALL}
{Fore.RED}[!] Warning: Use responsibly and only on systems you have permission to test{Style.RESET_ALL}
"""
        print(banner)
    
    def print_help(self):
        """Display help information"""
        help_text = f"""
{Fore.CYAN}╔══════════════════════════════════════════════════════════════════════════╗
║ {Fore.WHITE}                        AVAILABLE COMMANDS                              {Fore.CYAN}║
╚══════════════════════════════════════════════════════════════════════════╝{Style.RESET_ALL}

{Fore.GREEN}[01]{Style.RESET_ALL} {Fore.YELLOW}menu{Style.RESET_ALL}                 Interactive numbered menu system
{Fore.GREEN}[02]{Style.RESET_ALL} {Fore.YELLOW}help{Style.RESET_ALL} or {Fore.YELLOW}?{Style.RESET_ALL}             Show this help message
{Fore.GREEN}[03]{Style.RESET_ALL} {Fore.YELLOW}list{Style.RESET_ALL} [category]      List all tools or tools in a specific category
{Fore.GREEN}[04]{Style.RESET_ALL} {Fore.YELLOW}categories{Style.RESET_ALL}           List all tool categories
{Fore.GREEN}[05]{Style.RESET_ALL} {Fore.YELLOW}info{Style.RESET_ALL} <tool>          Show detailed information about a tool
{Fore.GREEN}[06]{Style.RESET_ALL} {Fore.YELLOW}examples{Style.RESET_ALL} <tool>      Show common usage examples for a tool
{Fore.GREEN}[07]{Style.RESET_ALL} {Fore.YELLOW}run{Style.RESET_ALL} <tool> [args]    Run a specific tool with optional arguments
{Fore.GREEN}[08]{Style.RESET_ALL} {Fore.YELLOW}search{Style.RESET_ALL} <keyword>     Search for tools by keyword
{Fore.GREEN}[09]{Style.RESET_ALL} {Fore.YELLOW}history{Style.RESET_ALL}              Show command history
{Fore.GREEN}[10]{Style.RESET_ALL} {Fore.YELLOW}add{Style.RESET_ALL}                  Add a custom tool
{Fore.GREEN}[11]{Style.RESET_ALL} {Fore.YELLOW}remove{Style.RESET_ALL} <tool>        Remove a custom tool
{Fore.GREEN}[12]{Style.RESET_ALL} {Fore.YELLOW}favorite{Style.RESET_ALL} <tool>      Add a tool to favorites
{Fore.GREEN}[13]{Style.RESET_ALL} {Fore.YELLOW}favorites{Style.RESET_ALL}            List favorite tools
{Fore.GREEN}[14]{Style.RESET_ALL} {Fore.YELLOW}preset{Style.RESET_ALL} <name>        Run a saved command preset
{Fore.GREEN}[15]{Style.RESET_ALL} {Fore.YELLOW}presets{Style.RESET_ALL}              List available presets
{Fore.GREEN}[16]{Style.RESET_ALL} {Fore.YELLOW}add-preset{Style.RESET_ALL}           Add a new command preset
{Fore.GREEN}[17]{Style.RESET_ALL} {Fore.YELLOW}quickscan{Style.RESET_ALL} <target>   Run a quick vulnerability scan
{Fore.GREEN}[18]{Style.RESET_ALL} {Fore.YELLOW}update{Style.RESET_ALL}               Check for updates
{Fore.GREEN}[19]{Style.RESET_ALL} {Fore.YELLOW}system{Style.RESET_ALL}               Display system information
{Fore.GREEN}[20]{Style.RESET_ALL} {Fore.YELLOW}clear{Style.RESET_ALL}                Clear the screen
{Fore.GREEN}[21]{Style.RESET_ALL} {Fore.YELLOW}exit{Style.RESET_ALL} or {Fore.YELLOW}quit{Style.RESET_ALL}         Exit PenTest Hub

{Fore.CYAN}[*] You can use numbers instead of commands (e.g., '3' for 'list'){Style.RESET_ALL}
"""
        print(help_text)
    
    def list_categories(self):
        """List all available tool categories"""
        categories = set()
        for tool in self.tools.values():
            if 'category' in tool:
                categories.add(tool['category'])
        
        print(f"\n{Fore.CYAN}╔══════════════════════════════════════════════════════════════════════════╗")
        print(f"║ {Fore.WHITE}                        AVAILABLE CATEGORIES                           {Fore.CYAN}║")
        print(f"╚══════════════════════════════════════════════════════════════════════════╝{Style.RESET_ALL}")
        
        if categories:
            for category in sorted(categories):
                count = sum(1 for tool in self.tools.values() if tool.get('category') == category)
                print(f"  {Fore.YELLOW}{category}{Style.RESET_ALL} ({count} tools)")
        else:
            print(f"  {Fore.YELLOW}No categories found.{Style.RESET_ALL}")
        print()
    
    def list_tools(self, category=None):
        """List tools, optionally filtered by category"""
        if category:
            tools_in_category = [name for name, tool in self.tools.items() 
                                if tool.get('category') == category]
            
            if not tools_in_category:
                print(f"\n{Fore.RED}No tools found in category '{category}'.{Style.RESET_ALL}\n")
                return
            
            print(f"\n{Fore.CYAN}╔══════════════════════════════════════════════════════════════════════════╗")
            print(f"║ {Fore.WHITE}                     TOOLS IN CATEGORY: {category.upper()}                  {Fore.CYAN}║")
            print(f"╚══════════════════════════════════════════════════════════════════════════╝{Style.RESET_ALL}")
            
            for name in sorted(tools_in_category):
                tool = self.tools[name]
                print(f"  {Fore.YELLOW}{name}{Style.RESET_ALL} - {tool['desc']}")
        else:
            print(f"\n{Fore.CYAN}╔══════════════════════════════════════════════════════════════════════════╗")
            print(f"║ {Fore.WHITE}                        ALL AVAILABLE TOOLS                            {Fore.CYAN}║")
            print(f"╚══════════════════════════════════════════════════════════════════════════╝{Style.RESET_ALL}")
            
            # Group tools by category
            by_category = {}
            for name, tool in self.tools.items():
                category = tool.get('category', 'Uncategorized')
                if category not in by_category:
                    by_category[category] = []
                by_category[category].append((name, tool))
            
            for category in sorted(by_category.keys()):
                print(f"\n{Fore.GREEN}{category.upper()}{Style.RESET_ALL}")
                for name, tool in sorted(by_category[category]):
                    print(f"  {Fore.YELLOW}{name}{Style.RESET_ALL} - {tool['desc']}")
        print()
    
    def search_tools(self, keyword):
        """Search for tools by keyword"""
        results = []
        keyword = keyword.lower()
        
        for tool_name, tool_info in self.tools.items():
            if (keyword in tool_name.lower() or 
                keyword in tool_info['desc'].lower() or 
                keyword in tool_info.get('category', '').lower()):
                results.append((tool_name, tool_info))
        
        if results:
            print(f"\n{Fore.CYAN}╔══════════════════════════════════════════════════════════════════════════╗")
            print(f"║ {Fore.WHITE}                     SEARCH RESULTS FOR: {keyword}                      {Fore.CYAN}║")
            print(f"╚══════════════════════════════════════════════════════════════════════════╝{Style.RESET_ALL}")
            
            for tool_name, tool_info in sorted(results):
                category = tool_info.get('category', 'Uncategorized')
                print(f"  {Fore.YELLOW}{tool_name}{Style.RESET_ALL} - {tool_info['desc']} {Fore.CYAN}[{category}]{Style.RESET_ALL}")
        else:
            print(f"\n{Fore.YELLOW}No tools found matching '{keyword}'.{Style.RESET_ALL}")
        print()
    
    def show_tool_info(self, tool_name):
        """Display detailed information about a tool"""
        if tool_name in self.tools:
            tool = self.tools[tool_name]
            
            print(f"\n{Fore.CYAN}╔══════════════════════════════════════════════════════════════════════════╗")
            print(f"║ {Fore.WHITE}                     TOOL INFORMATION: {tool_name.upper()}                {Fore.CYAN}║")
            print(f"╚══════════════════════════════════════════════════════════════════════════╝{Style.RESET_ALL}")
            
            print(f"  {Fore.CYAN}Description:{Style.RESET_ALL} {tool['desc']}")
            print(f"  {Fore.CYAN}Command:{Style.RESET_ALL} {tool['cmd']}")
            print(f"  {Fore.CYAN}Category:{Style.RESET_ALL} {tool.get('category', 'Uncategorized')}")
            
            # Check if tool is installed
            try:
                which_cmd = "where" if platform.system() == "Windows" else "which"
                subprocess.run([which_cmd, tool['cmd'].split()[0]], 
                               stdout=subprocess.PIPE, 
                               stderr=subprocess.PIPE, 
                               check=True)
                print(f"  {Fore.CYAN}Status:{Style.RESET_ALL} {Fore.GREEN}Installed{Style.RESET_ALL}")
            except:
                print(f"  {Fore.CYAN}Status:{Style.RESET_ALL} {Fore.RED}Not installed{Style.RESET_ALL}")
            
            print()
        else:
            print(f"\n{Fore.RED}Tool '{tool_name}' not found.{Style.RESET_ALL}\n")
    
    def show_examples(self, tool_name):
        """Show common usage examples for a tool"""
        if tool_name in self.tools:
            if tool_name in self.common_commands:
                examples = self.common_commands[tool_name]
                
                print(f"\n{Fore.CYAN}╔══════════════════════════════════════════════════════════════════════════╗")
                print(f"║ {Fore.WHITE}                     EXAMPLES FOR: {tool_name.upper()}                    {Fore.CYAN}║")
                print(f"╚══════════════════════════════════════════════════════════════════════════╝{Style.RESET_ALL}")
                
                for name, cmd in examples.items():
                    print(f"  {Fore.CYAN}{name}:{Style.RESET_ALL}")
                    print(f"    {cmd}")
            else:
                print(f"\n{Fore.YELLOW}No specific examples available for '{tool_name}'.{Style.RESET_ALL}")
            print()
        else:
            print(f"\n{Fore.RED}Tool '{tool_name}' not found.{Style.RESET_ALL}\n")
    
    def run_tool(self, tool_name, args=None):
        """Run a specific tool with optional arguments"""
        if tool_name in self.tools:
            cmd = self.tools[tool_name]["cmd"]
            command = cmd.split()
            
            if args:
                command.extend(args)
            
            print(f"\n{Fore.GREEN}Running {Fore.YELLOW}{tool_name}{Fore.GREEN}...{Style.RESET_ALL}\n")
            
            # Add to history
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            self.history.append({
                "timestamp": timestamp,
                "tool": tool_name,
                "command": " ".join(command)
            })
            self.save_history()
            
            try:
                subprocess.run(command)
                print(f"\n{Fore.GREEN}Command completed.{Style.RESET_ALL}\n")
            except FileNotFoundError:
                print(f"\n{Fore.RED}Error: Tool '{tool_name}' is not installed or not in PATH.{Style.RESET_ALL}")
                print(f"{Fore.YELLOW}You may need to install it using: sudo apt install {tool_name}{Style.RESET_ALL}\n")
            except Exception as e:
                print(f"\n{Fore.RED}Error running {tool_name}: {str(e)}{Style.RESET_ALL}\n")
        else:
            print(f"\n{Fore.RED}Tool '{tool_name}' not found.{Style.RESET_ALL}\n")
    
    def show_history(self):
        """Display command history"""
        if not self.history:
            print(f"\n{Fore.YELLOW}No command history available.{Style.RESET_ALL}\n")
            return
        
        print(f"\n{Fore.CYAN}╔══════════════════════════════════════════════════════════════════════════╗")
        print(f"║ {Fore.WHITE}                        COMMAND HISTORY                                {Fore.CYAN}║")
        print(f"╚══════════════════════════════════════════════════════════════════════════╝{Style.RESET_ALL}")
        
        for i, entry in enumerate(self.history[-20:], 1):  # Show last 20 entries
            print(f"  {Fore.GREEN}{i}.{Style.RESET_ALL} [{entry['timestamp']}] {Fore.YELLOW}{entry['tool']}{Style.RESET_ALL}: {entry['command']}")
        print()
    
    def add_tool_interactive(self):
        """Interactive prompt to add a custom tool"""
        print(f"\n{Fore.CYAN}╔══════════════════════════════════════════════════════════════════════════╗")
        print(f"║ {Fore.WHITE}                        ADD CUSTOM TOOL                                {Fore.CYAN}║")
        print(f"╚══════════════════════════════════════════════════════════════════════════╝{Style.RESET_ALL}")
        
        name = input(f"{Fore.GREEN}Tool name:{Style.RESET_ALL} ").strip()
        if not name:
            print(f"{Fore.RED}Tool name cannot be empty.{Style.RESET_ALL}\n")
            return
        
        if name in self.tools and name not in self.custom_tools:
            print(f"{Fore.RED}Cannot override built-in tool '{name}'.{Style.RESET_ALL}\n")
            return
        
        description = input(f"{Fore.GREEN}Description:{Style.RESET_ALL} ").strip()
        command = input(f"{Fore.GREEN}Command:{Style.RESET_ALL} ").strip()
        category = input(f"{Fore.GREEN}Category:{Style.RESET_ALL} ").strip() or "Custom"
        
        if not command:
            print(f"{Fore.RED}Command cannot be empty.{Style.RESET_ALL}\n")
            return
        
        self.tools[name] = {
            "desc": description,
            "cmd": command,
            "category": category
        }
        
        self.custom_tools[name] = self.tools[name]
        
        # Add to category
        if category not in self.categories:
            self.categories[category] = []
        if name not in self.categories[category]:
            self.categories[category].append(name)
        
        self.save_custom_tools()
        print(f"\n{Fore.GREEN}Tool '{name}' added successfully.{Style.RESET_ALL}\n")
    
    def remove_custom_tool(self, name):
        """Remove a custom tool"""
        if name in self.custom_tools:
            # Remove from main tools dictionary
            if name in self.tools:
                del self.tools[name]
            
            # Remove from custom tools
            del self.custom_tools[name]
            
            # Remove from categories
            for category, tools in self.categories.items():
                if name in tools:
                    tools.remove(name)
            
            self.save_custom_tools()
            print(f"\n{Fore.GREEN}Tool '{name}' removed successfully.{Style.RESET_ALL}\n")
        else:
            print(f"\n{Fore.RED}'{name}' is not a custom tool or does not exist.{Style.RESET_ALL}\n")
    
    def check_for_updates(self):
        """Check for updates to PenTest Hub"""
        print(f"\n{Fore.CYAN}╔══════════════════════════════════════════════════════════════════════════╗")
        print(f"║ {Fore.WHITE}                        UPDATE CHECK                                   {Fore.CYAN}║")
        print(f"╚══════════════════════════════════════════════════════════════════════════╝{Style.RESET_ALL}")
        
        print(f"{Fore.GREEN}Current version: {self.version}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Checking for updates...{Style.RESET_ALL}")
        
        # Simulate update check
        time.sleep(1.5)
        print(f"{Fore.GREEN}You are running the latest version of PenTest Hub.{Style.RESET_ALL}\n")
    
    def system_info(self):
        """Display system information"""
        print(f"\n{Fore.CYAN}╔══════════════════════════════════════════════════════════════════════════╗")
        print(f"║ {Fore.WHITE}                        SYSTEM INFORMATION                             {Fore.CYAN}║")
        print(f"╚══════════════════════════════════════════════════════════════════════════╝{Style.RESET_ALL}")
        
        print(f"  {Fore.CYAN}OS:{Style.RESET_ALL} {platform.system()} {platform.release()}")
        print(f"  {Fore.CYAN}Python:{Style.RESET_ALL} {platform.python_version()}")
        print(f"  {Fore.CYAN}Hostname:{Style.RESET_ALL} {socket.gethostname()}")
        
        # Check internet connectivity
        try:
            requests.get("https://www.google.com", timeout=3)
            print(f"  {Fore.CYAN}Internet:{Style.RESET_ALL} {Fore.GREEN}Connected{Style.RESET_ALL}")
        except:
            print(f"  {Fore.CYAN}Internet:{Style.RESET_ALL} {Fore.RED}Not connected{Style.RESET_ALL}")
        
        print()
    
    def add_to_favorites(self, tool_name):
        """Add a tool to favorites"""
        if tool_name in self.tools:
            if not hasattr(self, 'favorites'):
                self.favorites = []
            
            if tool_name not in self.favorites:
                self.favorites.append(tool_name)
                self.save_config()
                print(f"\n{Fore.GREEN}Added '{tool_name}' to favorites.{Style.RESET_ALL}\n")
            else:
                print(f"\n{Fore.YELLOW}'{tool_name}' is already in favorites.{Style.RESET_ALL}\n")
        else:
            print(f"\n{Fore.RED}Tool '{tool_name}' not found.{Style.RESET_ALL}\n")
    
    def list_favorites(self):
        """List favorite tools"""
        if not hasattr(self, 'favorites') or not self.favorites:
            print(f"\n{Fore.YELLOW}No favorite tools added yet.{Style.RESET_ALL}\n")
            return
        
        print(f"\n{Fore.CYAN}╔══════════════════════════════════════════════════════════════════════════╗")
        print(f"║ {Fore.WHITE}                        FAVORITE TOOLS                                 {Fore.CYAN}║")
        print(f"╚══════════════════════════════════════════════════════════════════════════╝{Style.RESET_ALL}")
        
        for i, tool_name in enumerate(self.favorites, 1):
            if tool_name in self.tools:
                tool = self.tools[tool_name]
                print(f"  {Fore.GREEN}{i}.{Style.RESET_ALL} {Fore.YELLOW}{tool_name}{Style.RESET_ALL} - {tool['desc']}")
            else:
                print(f"  {Fore.GREEN}{i}.{Style.RESET_ALL} {Fore.YELLOW}{tool_name}{Style.RESET_ALL} - {Fore.RED}Tool not found{Style.RESET_ALL}")
        print()
    
    def save_config(self):
        """Save configuration to file"""
        config = {
            "favorites": getattr(self, 'favorites', []),
            "presets": getattr(self, 'presets', {})
        }
        
        try:
            with open(self.config_file, 'w') as f:
                json.dump(config, f, indent=2)
        except Exception as e:
            print(f"{Fore.RED}Error saving configuration: {str(e)}{Style.RESET_ALL}")
    
    def save_custom_tools(self):
        """Save custom tools to file"""
        try:
            with open(self.custom_tools_file, 'w') as f:
                json.dump(self.custom_tools, f, indent=2)
        except Exception as e:
            print(f"{Fore.RED}Error saving custom tools: {str(e)}{Style.RESET_ALL}")
    
    def save_history(self):
        """Save command history to file"""
        try:
            with open(self.history_file, 'w') as f:
                json.dump(self.history, f, indent=2)
        except Exception as e:
            print(f"{Fore.RED}Error saving history: {str(e)}{Style.RESET_ALL}")

    def run(self):
        """Main application loop"""
        print(f"{Fore.CYAN}PenTest Hub v{self.version} - Your Penetration Testing Command Center{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Type 'help' to see available commands{Style.RESET_ALL}")
        
        while True:
            try:
                command = input(f"{Fore.GREEN}pentesthub> {Style.RESET_ALL}").strip()
                if command.lower() == 'exit' or command.lower() == 'quit':
                    break
                # Process commands here
                # This would be expanded with command handling logic
                print(f"Command entered: {command}")
            except KeyboardInterrupt:
                print("\nExiting PenTest Hub...")
                break
            except Exception as e:
                print(f"{Fore.RED}Error: {str(e)}{Style.RESET_ALL}")

if __name__ == "__main__":
    hub = PenTestHub()
    hub.run()
